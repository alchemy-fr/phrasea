
main: e:expression
    function __finalise(&$result) {
        $result['data'] = $result['e']['data'];
        unset($result['e']);
    }

expression: left:and_expression (] "OR" ] right:and_expression ) *
    function __finalise(&$result) {
        $result['operator'] = 'OR';
        $conditions = [$result['left']['data']];

        if (isset($result['right']['_matchrule'])) {
            $conditions[] = $result['right']['data'];
        } else {
            foreach ($result['right'] ?? [] as $right) {
                $conditions[] = $right['data'];
            }
        }
        unset($result['left'], $result['right']);

        if (count($conditions) === 1) {
            $result['data'] = $conditions[0];
            return;
        }

        $result['data'] = [
            'type' => 'expression',
            'operator' => 'OR',
            'conditions' => $conditions,
        ];
    }

and_expression: left:condition (] "AND" ] right:condition ) *
    function __finalise(&$result) {
        $conditions = [$result['left']['data']];
        if (isset($result['right']['_matchrule'])) {
            $conditions[] = $result['right']['data'];
        } else {
            foreach ($result['right'] ?? [] as $right) {
                $conditions[] = $right['data'];
            }
        }
        unset($result['left'], $result['right']);

        if (count($conditions) === 1) {
            $result['data'] = $conditions[0];
            return;
        }

        $result['data'] = [
            'type' => 'expression',
            'operator' => 'AND',
            'conditions' => $conditions,
        ];
    }

condition: "(" > e:expression > ")"
    | e:not_expression
    | e:criteria
    function __finalise(&$result) {
        $result['data'] = $result['e']['data'];
        unset($result['e']);
    }

not_expression: "NOT" __ e:expression
    function __finalise(&$result) {
        $result['data'] = [
            'type' => 'expression',
            'operator' => 'NOT',
            'conditions' => [$result['e']['data']],
        ];
        unset($result['e']);
    }

criteria: field:field op:operator
    function __finalise(&$result) {
        $result['data'] = [
            'type' => 'criteria',
            'leftOperand' => $result['field']['data'],
            ...$result['op']['data'],
        ];
        unset($result['field'], $result['op']);
    }

builtin_field: "@" keyword
    function __finalise(&$result) {
        $result['data'] = ['field' => $result['text']];
    }

field_name: keyword
    function __finalise(&$result) {
        $result['data'] = ['field' => $result['text']];
    }

field: f:builtin_field | f:field_name
    function __finalise(&$result) {
        $result['data'] = $result['f']['data'];
        unset($result['f']);
    }

boolean: "true" | "false"
    function __finalise(&$result) {
        $result['data'] = $result['text'] === 'true';
    }

operator: ] op:between_operator | ] op:in_operator | ] op:ending_operator | > op:simple_operator
    function __finalise(&$result) {
        $result['data'] = $result['op']['data'];
        unset($result['op']);
    }

between_operator: "BETWEEN" ] left:value ] "AND" ] right:value
    function __finalise(&$result) {
        $result['data'] = [
            'operator' => 'BETWEEN',
            'rightOperand' => [$result['left']['data'], $result['right']['data']],
        ];
        unset($result['left'], $result['right']);
    }

ending_operator: ("IS" ] "MISSING") | "EXISTS"
    function __finalise(&$result) {
        $assoc = [
            'IS_MISSING' => 'MISSING',
            'EXISTS' => 'EXISTS',
        ];
        $result['data'] = [
            'operator' => $assoc[preg_replace('#\s+#', '_', $result['text'])],
        ];
    }

in_operator: not:("NOT" ] )? "IN" > "(" > first:value (> "," > others:value)* > ")"
    function __finalise(&$result) {
        $values = [$result['first']['data']];

        if (isset($result['others']['_matchrule'])) {
            $values[] = $result['others']['data'];
        } else {
            foreach ($result['others'] ?? [] as $v) {
                $values[] = $v['data'];
            }
        }

        $result['data'] = [
            'operator' => isset($result['not']) ? 'NOT_IN' : 'IN',
            'rightOperand' => $values,
        ];
        unset($result['first'], $result['others']);
    }

simple_operator: op:/([<>]?=|!=|[<>]|CONTAINS|MATCHES|STARTS\s+WITH)/ > v:field_or_value
    function __finalise(&$result) {
        $result['data'] = [
            'operator' => preg_replace('#\s+#', '_', $result['op']['text']),
            'rightOperand' => $result['v']['data'],
        ];
        unset($result['op'], $result['v']);
    }

field_or_value: v:field | v:value
    function __finalise(&$result) {
        $result['data'] = $result['v']['data'];
        unset($result['v']);
    }

value: v:number | v:quoted_string | v:boolean | v:field
    function __finalise(&$result) {
        $result['data'] = $result['v']['data'];
        unset($result['v']);
    }

int: /[0-9]+/
    function __finalise(&$result) {
        $result['data'] = (int) $result['text'];
    }

decimal: int? "." int
    function __finalise(&$result) {
        $result['data'] = (float) $result['text'];
    }

quoted_string: /"[^"]*"/
    function __finalise(&$result) {
        $result['data'] = ['literal' => substr($result['text'], 1, -1)];
    }

number: v:int | v:decimal
    function __finalise(&$result) {
        $result['data'] = $result['v']['data'];
        unset($result['v']);
    }

alpha: /[a-zA-Z_]/
alphanum: /[a-zA-Z_0-9-]/

keyword: alpha alphanum*
